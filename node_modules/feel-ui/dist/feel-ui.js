(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.FeelUi = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//Temporary work around for Angular2#4902
///<reference path="./node_modules/angular2/typings/browser.d.ts"/>
var button_1 = require("./src/button");
exports.ButtonComponent = button_1.ButtonComponent;
var menu_bar_1 = require("./src/menu-bar");
exports.MenuBar = menu_bar_1.MenuBar;
var menu_panel_1 = require("./src/menu-panel");
exports.MenuPanel = menu_panel_1.MenuPanel;
var input_1 = require("./src/input");
exports.InputComponent = input_1.InputComponent;
var notification_provider_1 = require("./src/notification-provider");
exports.NotificationProvider = notification_provider_1.NotificationProvider;
var table_1 = require("./src/table");
exports.TableComponent = table_1.TableComponent;
var slider_1 = require("./src/slider");
exports.Slider = slider_1.Slider;
},{"./src/button":3,"./src/input":4,"./src/menu-bar":5,"./src/menu-panel":6,"./src/notification-provider":7,"./src/slider":9,"./src/table":10}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var common_1 = require("angular2/common");
var ButtonComponent = (function () {
    function ButtonComponent() {
    }
    __decorate([
        core_1.Input()
    ], ButtonComponent.prototype, "flat", void 0);
    __decorate([
        core_1.Input()
    ], ButtonComponent.prototype, "text", void 0);
    ButtonComponent = __decorate([
        core_1.Component({
            directives: [common_1.NgClass],
            selector: "feel-button",
            template: "<button type='button' [ngClass]=\"{ 'btn-flat': flat }\" >{{text}}</button>"
        })
    ], ButtonComponent);
    return ButtonComponent;
})();
exports.ButtonComponent = ButtonComponent;
},{"angular2/common":2,"angular2/core":2}],4:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var common_1 = require("angular2/common");
var InputComponent = (function () {
    function InputComponent() {
        this.multiline = false;
        this.valueChange = new core_1.EventEmitter();
        this._rows = 2;
    }
    InputComponent.prototype.onInput = function (event) {
        this.value = event;
        this.valueChange.emit(event);
        var rows = this.value.split("\n").length;
        if (rows < 2) {
            rows = 2;
        }
        this._rows = rows;
    };
    __decorate([
        core_1.Input()
    ], InputComponent.prototype, "label", void 0);
    __decorate([
        core_1.Input()
    ], InputComponent.prototype, "value", void 0);
    __decorate([
        core_1.Input()
    ], InputComponent.prototype, "multiline", void 0);
    __decorate([
        core_1.Output()
    ], InputComponent.prototype, "valueChange", void 0);
    InputComponent = __decorate([
        core_1.Component({
            directives: [common_1.NgClass, common_1.NgIf],
            selector: "feel-input",
            template: "<label>{{label}}</label>\n               <textarea *ngIf=\"multiline\" [ngModel]=value (ngModelChange)=\"onInput($event)\" [rows]=_rows></textarea>\n               <input *ngIf=\"!multiline\" type=\"text\" [ngModel]=value (ngModelChange)=\"onInput($event)\" />"
        })
    ], InputComponent);
    return InputComponent;
})();
exports.InputComponent = InputComponent;
},{"angular2/common":2,"angular2/core":2}],5:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var button_1 = require("./button");
var menu_panel_1 = require("./menu-panel");
var MenuBar = (function () {
    function MenuBar() {
        this.isMenuOpen = false;
    }
    MenuBar.prototype.toggleMenuPanel = function () {
        this.isMenuOpen = !this.isMenuOpen;
    };
    MenuBar.prototype.onMenuClose = function () {
        this.isMenuOpen = false;
    };
    __decorate([
        core_1.Input()
    ], MenuBar.prototype, "title", void 0);
    MenuBar = __decorate([
        core_1.Component({
            directives: [button_1.ButtonComponent, menu_panel_1.MenuPanel],
            selector: "feel-menu-bar",
            template: "<feel-button [text]=\"'M'\" (click)=toggleMenuPanel()></feel-button>\n               <div class=\"title\">\n                <h1>{{title}}</h1>\n                </div>\n               <feel-menu-panel [open]=\"isMenuOpen\" (close)=\"onMenuClose()\"></feel-menu-panel>"
        })
    ], MenuBar);
    return MenuBar;
})();
exports.MenuBar = MenuBar;
},{"./button":3,"./menu-panel":6,"angular2/core":2}],6:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var common_1 = require("angular2/common");
var button_1 = require("./button");
var router_1 = require('angular2/router');
var MenuPanel = (function () {
    function MenuPanel() {
        this.close = new core_1.EventEmitter();
    }
    MenuPanel.prototype.closeMenuPanel = function () {
        this.open = false;
        this.close.next(null);
    };
    __decorate([
        core_1.Input()
    ], MenuPanel.prototype, "open", void 0);
    MenuPanel = __decorate([
        core_1.Component({
            directives: [common_1.NgClass, button_1.ButtonComponent, router_1.RouterLink],
            selector: "feel-menu-panel",
            events: ['close'],
            template: "<div [ngClass]=\"{ 'show': open }\" >\n                  <div class=\"menu-title\">\n                    <h1>Menu</h1>\n                    <feel-button [text]=\"'X'\" (click)=closeMenuPanel()></feel-button>\n                  </div>\n                  <div class=\"menu-options\">\n                    <a [routerLink]=\"['/Home']\"><div class=\"menu-item\">Home</div></a>\n                    <a [routerLink]=\"['/Buttons']\"><div class=\"menu-item\">Button</div></a>\n                    <a [routerLink]=\"['/Input']\"><div class=\"menu-item\">Input</div></a>\n                    <a [routerLink]=\"['/Notifications']\"><div class=\"menu-item\">Notifications</div></a>\n                    <a [routerLink]=\"['/Table']\"><div class=\"menu-item\">Table</div></a>\n                    <a [routerLink]=\"['/Slider']\"><div class=\"menu-item\">Slider</div></a>\n                  </div>\n               </div>"
        })
    ], MenuPanel);
    return MenuPanel;
})();
exports.MenuPanel = MenuPanel;
},{"./button":3,"angular2/common":2,"angular2/core":2,"angular2/router":2}],7:[function(require,module,exports){
var NotificationProvider = (function () {
    function NotificationProvider() {
        this._notificationElement = document.getElementById("notification-stream");
        if (this._notificationElement === null) {
            this._notificationElement = document.createElement("div");
            this._notificationElement.id = "notification-stream";
            document.body.appendChild(this._notificationElement);
        }
    }
    NotificationProvider.prototype.showSuccess = function (title, message) {
        var newNotification = document.createElement("div");
        newNotification.className = "notification success";
        this._showNotification(newNotification, title, message);
    };
    NotificationProvider.prototype.showError = function (title, message) {
        var newNotification = document.createElement("div");
        newNotification.className = "notification error";
        this._showNotification(newNotification, title, message);
    };
    NotificationProvider.prototype._showNotification = function (notificationElement, title, message) {
        var _this = this;
        if (title) {
            notificationElement.innerHTML += "<div class='title'>" + title + "</div>";
        }
        if (message) {
            notificationElement.innerHTML += "<div class='message'>" + message + "</div>";
        }
        this._notificationElement.appendChild(notificationElement);
        setTimeout(function () {
            _this._notificationElement.removeChild(notificationElement);
        }, 5000);
    };
    return NotificationProvider;
})();
exports.NotificationProvider = NotificationProvider;
},{}],8:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require('angular2/core');
var SortPipe = (function () {
    function SortPipe() {
    }
    SortPipe.prototype.transform = function (value, args) {
        var propertyName = args[0];
        if (propertyName[0] === "-") {
            propertyName = propertyName.substr(1);
        }
        var sortedValue = value.sort(function (a, b) {
            if (a[propertyName] < b[propertyName]) {
                return -1;
            }
            else if (a[propertyName] > b[propertyName]) {
                return 1;
            }
            else {
                return 0;
            }
        });
        if (args[0][0] === "-") {
            sortedValue = sortedValue.reverse();
        }
        return sortedValue;
    };
    SortPipe = __decorate([
        core_1.Pipe({ name: 'sort',
            pure: false
        })
    ], SortPipe);
    return SortPipe;
})();
exports.SortPipe = SortPipe;
},{"angular2/core":2}],9:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var common_1 = require("angular2/common");
var Slider = (function () {
    function Slider() {
        this.valueChange = new core_1.EventEmitter();
        this._calculateOffset();
    }
    Slider.prototype._calculateOffset = function () {
        this._offset = ((this.value / this.maximum) * 100).toString() + "%";
    };
    Slider.prototype._startDrag = function (event) {
        this._buttonElement = event.target;
        document.onmouseup = this._stopDrag.bind(this);
        document.onmousemove = this._handleDrag.bind(this);
    };
    Slider.prototype._handleDrag = function (event) {
        var element = this._buttonElement;
        var offsetTotal = this._buttonElement.offsetLeft;
        while (element = element.offsetParent) {
            if (!isNaN(element.offsetLeft)) {
                offsetTotal += element.offsetLeft;
            }
        }
        var value = (event.pageX / this._buttonElement.parentElement.offsetWidth) * this.maximum;
        if (value < 0) {
            this.value = 0;
        }
        else if (value > this.maximum) {
            this.value = this.maximum;
        }
        else {
            this.value = value;
        }
        this._calculateOffset();
        this._buttonElement.style.left = this._offset;
        console.log(this.value);
        event.preventDefault();
        this.valueChange.emit(this.value);
    };
    Slider.prototype._stopDrag = function () {
        document.onmouseup = null;
        document.onmousemove = null;
    };
    __decorate([
        core_1.Input()
    ], Slider.prototype, "value", void 0);
    __decorate([
        core_1.Output()
    ], Slider.prototype, "valueChange", void 0);
    __decorate([
        core_1.Input()
    ], Slider.prototype, "maximum", void 0);
    Slider = __decorate([
        core_1.Component({
            directives: [common_1.NgClass],
            selector: "feel-slider",
            template: "<div class=\"slider-track\">\n                  <div class=\"slider-button\" [style.left]=\"_offset\" (mousedown)=\"_startDrag($event)\"></div>\n               </div>"
        })
    ], Slider);
    return Slider;
})();
exports.Slider = Slider;
},{"angular2/common":2,"angular2/core":2}],10:[function(require,module,exports){
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("angular2/core");
var common_1 = require("angular2/common");
var sort_pipe_1 = require("./pipes/sort-pipe");
var TableComponent = (function () {
    function TableComponent() {
        this.sortOrder = "something";
        this.sortItems = ["something"];
    }
    TableComponent.prototype.addSort = function (propertyName) {
        if (this.sortOrder === propertyName) {
            this.sortOrder = "-" + propertyName;
        }
        else {
            this.sortOrder = propertyName;
        }
        this.sortItems[0] = this.sortOrder;
    };
    __decorate([
        core_1.Input()
    ], TableComponent.prototype, "data", void 0);
    __decorate([
        core_1.Input()
    ], TableComponent.prototype, "columns", void 0);
    TableComponent = __decorate([
        core_1.Component({
            directives: [common_1.NgClass],
            selector: "feel-table",
            pipes: [sort_pipe_1.SortPipe],
            //changeDetection: ChangeDetectionStrategy.OnPush,
            template: "<table>\n                  <thead>\n                     <th *ngFor=\"#column of columns\" (click)=addSort(column.propertyName)>\n                        <span>{{ column.propertyName }}</span>\n                        <span [ngClass]=\"{\n                                            'ascending': sortItems[0] === column.propertyName,\n                                            'descending': sortItems[0] === '-' + column.propertyName,\n                                            'sort-icon': true\n                                          }\" ></span>\n                     </th>\n                  </thead>\n                  <tbody>\n                     <tr *ngFor=\"#dataItem of data | sort: sortOrder\">\n                        <td *ngFor=\"#column of columns\">{{ dataItem[column.propertyName] }}</td>\n                     </tr>\n                  </tbody>\n               </table>"
        })
    ], TableComponent);
    return TableComponent;
})();
exports.TableComponent = TableComponent;
},{"./pipes/sort-pipe":8,"angular2/common":2,"angular2/core":2}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJmZWVsLXVpLnRzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsInNyYy9idXR0b24udHMiLCJzcmMvaW5wdXQudHMiLCJzcmMvbWVudS1iYXIudHMiLCJzcmMvbWVudS1wYW5lbC50cyIsInNyYy9ub3RpZmljYXRpb24tcHJvdmlkZXIudHMiLCJzcmMvcGlwZXMvc29ydC1waXBlLnRzIiwic3JjL3NsaWRlci50cyIsInNyYy90YWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBLHlDQUF5QztBQUN6QyxtRUFBbUU7QUFFbkUsdUJBQWdDLGNBQWMsQ0FBQyxDQUFBO0FBUzVDLHVCQUFlO0FBUmxCLHlCQUF3QixnQkFBZ0IsQ0FBQyxDQUFBO0FBU3RDLGVBQU87QUFSViwyQkFBMEIsa0JBQWtCLENBQUMsQ0FBQTtBQVMxQyxpQkFBUztBQVJaLHNCQUErQixhQUFhLENBQUMsQ0FBQTtBQVMxQyxzQkFBYztBQVJqQixzQ0FBcUMsNkJBQTZCLENBQUMsQ0FBQTtBQVNoRSw0QkFBb0I7QUFSdkIsc0JBQStCLGFBQWEsQ0FBQyxDQUFBO0FBUzFDLHNCQUFjO0FBUmpCLHVCQUF1QixjQUFjLENBQUMsQ0FBQTtBQVNuQyxjQUFNO0FBQ1A7QUNuQkY7Ozs7Ozs7O0FDQUEscUJBQWdDLGVBQWUsQ0FBQyxDQUFBO0FBQ2hELHVCQUF3QixpQkFBaUIsQ0FBQyxDQUFBO0FBRTFDO0lBQUE7SUFTQyxDQUFDO0lBRkM7UUFBQyxZQUFLLEVBQUU7T0FBQyxpQ0FBSSxVQUFVO0lBQ3ZCO1FBQUMsWUFBSyxFQUFFO09BQUMsaUNBQUksVUFBUztJQVJ6QjtRQUFDLGdCQUFTLENBQUM7WUFDUCxVQUFVLEVBQUUsQ0FBQyxnQkFBTyxDQUFDO1lBQ3JCLFFBQVEsRUFBRSxhQUFhO1lBQ3ZCLFFBQVEsRUFBRSw2RUFBNkU7U0FDMUYsQ0FBQzt3QkFLQTtJQUFELHNC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QyxTQUFTLEdBQUcsR0FBRyxHQUFHLFlBQVksQ0FBQztRQUN0QyxDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUM7WUFDSixJQUFJLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQztRQUNoQyxDQUFDO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3JDLENBQUM7SUFkRDtRQUFDLFlBQUssRUFBRTtPQUFDLGdDQUFJLFVBQWE7SUFDMUI7UUFBQyxZQUFLLEVBQUU7T0FBQyxtQ0FBTyxVQUFhO0lBMUJoQztRQUFDLGdCQUFTLENBQUM7WUFDUCxVQUFVLEVBQUUsQ0FBRSxnQkFBTyxDQUFFO1lBQ3ZCLFFBQVEsRUFBRSxZQUFZO1lBQ3RCLEtBQUssRUFBRSxDQUFFLG9CQUFRLENBQUU7WUFDbkIsa0RBQWtEO1lBQ2xELFFBQVEsRUFBRSwrM0JBZ0JVO1NBQ3ZCLENBQUM7dUJBa0JBO0lBQUQscUJBQUM7QUFBRCxDQXhDRCxBQXdDRSxJQUFBO0FBakJXLHNCQUFjLGlCQWlCekIsQ0FBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvL1RlbXBvcmFyeSB3b3JrIGFyb3VuZCBmb3IgQW5ndWxhcjIjNDkwMlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi90eXBpbmdzL2Jyb3dzZXIuZC50c1wiLz5cclxuXHJcbmltcG9ydCB7IEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gXCIuL3NyYy9idXR0b25cIjtcclxuaW1wb3J0IHsgTWVudUJhciB9IGZyb20gXCIuL3NyYy9tZW51LWJhclwiO1xyXG5pbXBvcnQgeyBNZW51UGFuZWwgfSBmcm9tIFwiLi9zcmMvbWVudS1wYW5lbFwiO1xyXG5pbXBvcnQgeyBJbnB1dENvbXBvbmVudCB9IGZyb20gXCIuL3NyYy9pbnB1dFwiO1xyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25Qcm92aWRlciB9IGZyb20gXCIuL3NyYy9ub3RpZmljYXRpb24tcHJvdmlkZXJcIjtcclxuaW1wb3J0IHsgVGFibGVDb21wb25lbnQgfSBmcm9tIFwiLi9zcmMvdGFibGVcIjtcclxuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSBcIi4vc3JjL3NsaWRlclwiO1xyXG5cclxuZXhwb3J0IHtcclxuICAgQnV0dG9uQ29tcG9uZW50LFxyXG4gICBNZW51QmFyLFxyXG4gICBNZW51UGFuZWwsXHJcbiAgIElucHV0Q29tcG9uZW50LFxyXG4gICBOb3RpZmljYXRpb25Qcm92aWRlcixcclxuICAgVGFibGVDb21wb25lbnQsXHJcbiAgIFNsaWRlclxyXG59O1xyXG4iLCIiLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0fSBmcm9tIFwiYW5ndWxhcjIvY29yZVwiO1xyXG5pbXBvcnQgeyBOZ0NsYXNzIH0gZnJvbSBcImFuZ3VsYXIyL2NvbW1vblwiO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBkaXJlY3RpdmVzOiBbTmdDbGFzc10sXHJcbiAgICBzZWxlY3RvcjogXCJmZWVsLWJ1dHRvblwiLFxyXG4gICAgdGVtcGxhdGU6IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIFtuZ0NsYXNzXT1cXFwieyAnYnRuLWZsYXQnOiBmbGF0IH1cXFwiID57e3RleHR9fTwvYnV0dG9uPlwiXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBCdXR0b25Db21wb25lbnQge1xyXG5cclxuICAgQElucHV0KCkgZmxhdDogYm9vbGVhbjtcclxuICAgQElucHV0KCkgdGV4dDogc3RyaW5nO1xyXG4gfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gXCJhbmd1bGFyMi9jb3JlXCI7XHJcbmltcG9ydCB7IE5nQ2xhc3MsIE5nTW9kZWwsIE5nSWYgfSBmcm9tIFwiYW5ndWxhcjIvY29tbW9uXCI7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgZGlyZWN0aXZlczogW05nQ2xhc3MsIE5nSWZdLFxyXG4gICAgc2VsZWN0b3I6IFwiZmVlbC1pbnB1dFwiLFxyXG4gICAgdGVtcGxhdGU6IGA8bGFiZWw+e3tsYWJlbH19PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgPHRleHRhcmVhICpuZ0lmPVwibXVsdGlsaW5lXCIgW25nTW9kZWxdPXZhbHVlIChuZ01vZGVsQ2hhbmdlKT1cIm9uSW5wdXQoJGV2ZW50KVwiIFtyb3dzXT1fcm93cz48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICAgICA8aW5wdXQgKm5nSWY9XCIhbXVsdGlsaW5lXCIgdHlwZT1cInRleHRcIiBbbmdNb2RlbF09dmFsdWUgKG5nTW9kZWxDaGFuZ2UpPVwib25JbnB1dCgkZXZlbnQpXCIgLz5gXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJbnB1dENvbXBvbmVudCB7XHJcblxyXG4gICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xyXG4gICBASW5wdXQoKSB2YWx1ZTogc3RyaW5nO1xyXG4gICBASW5wdXQoKSBtdWx0aWxpbmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgcHJpdmF0ZSBfcm93czogbnVtYmVyID0gMjtcclxuXHJcbiAgIG9uSW5wdXQoZXZlbnQ6IHN0cmluZykge1xyXG5cclxuICAgICAgdGhpcy52YWx1ZSA9IGV2ZW50O1xyXG4gICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoZXZlbnQpO1xyXG5cclxuICAgICAgbGV0IHJvd3MgPSB0aGlzLnZhbHVlLnNwbGl0KFwiXFxuXCIpLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChyb3dzIDwgMikge1xyXG4gICAgICAgICByb3dzID0gMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fcm93cyA9IHJvd3M7XHJcbiAgIH1cclxuIH1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gXCJhbmd1bGFyMi9jb3JlXCI7XHJcbmltcG9ydCB7IEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gXCIuL2J1dHRvblwiO1xyXG5pbXBvcnQgeyBNZW51UGFuZWwgfSBmcm9tIFwiLi9tZW51LXBhbmVsXCI7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgZGlyZWN0aXZlczogWyBCdXR0b25Db21wb25lbnQsIE1lbnVQYW5lbCBdLFxyXG4gICAgc2VsZWN0b3I6IFwiZmVlbC1tZW51LWJhclwiLFxyXG4gICAgdGVtcGxhdGU6IGA8ZmVlbC1idXR0b24gW3RleHRdPVwiJ00nXCIgKGNsaWNrKT10b2dnbGVNZW51UGFuZWwoKT48L2ZlZWwtYnV0dG9uPlxyXG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5cclxuICAgICAgICAgICAgICAgIDxoMT57e3RpdGxlfX08L2gxPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgIDxmZWVsLW1lbnUtcGFuZWwgW29wZW5dPVwiaXNNZW51T3BlblwiIChjbG9zZSk9XCJvbk1lbnVDbG9zZSgpXCI+PC9mZWVsLW1lbnUtcGFuZWw+YFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWVudUJhciB7XHJcblxyXG4gICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xyXG4gICBwdWJsaWMgaXNNZW51T3BlbjogYm9vbGVhbjtcclxuXHJcbiAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICB0aGlzLmlzTWVudU9wZW4gPSBmYWxzZTtcclxuICAgfVxyXG5cclxuICAgcHVibGljIHRvZ2dsZU1lbnVQYW5lbCgpIHtcclxuICAgICB0aGlzLmlzTWVudU9wZW4gPSAhdGhpcy5pc01lbnVPcGVuXHJcbiAgIH1cclxuXHJcbiAgIHB1YmxpYyBvbk1lbnVDbG9zZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5pc01lbnVPcGVuID0gZmFsc2U7XHJcbiAgIH1cclxuIH1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImFuZ3VsYXIyL2NvcmVcIjtcclxuaW1wb3J0IHsgTmdDbGFzcyB9IGZyb20gXCJhbmd1bGFyMi9jb21tb25cIjtcclxuaW1wb3J0IHsgQnV0dG9uQ29tcG9uZW50IH0gZnJvbSBcIi4vYnV0dG9uXCI7XHJcbmltcG9ydCB7IFJvdXRlckxpbmsgfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG5AQ29tcG9uZW50KHtcclxuICAgIGRpcmVjdGl2ZXM6IFtOZ0NsYXNzLCBCdXR0b25Db21wb25lbnQsIFJvdXRlckxpbmsgXSxcclxuICAgIHNlbGVjdG9yOiBcImZlZWwtbWVudS1wYW5lbFwiLFxyXG4gICAgZXZlbnRzOiBbJ2Nsb3NlJ10sXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgW25nQ2xhc3NdPVxcXCJ7ICdzaG93Jzogb3BlbiB9XFxcIiA+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZW51LXRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgxPk1lbnU8L2gxPlxyXG4gICAgICAgICAgICAgICAgICAgIDxmZWVsLWJ1dHRvbiBbdGV4dF09XCInWCdcIiAoY2xpY2spPWNsb3NlTWVudVBhbmVsKCk+PC9mZWVsLWJ1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZW51LW9wdGlvbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy9Ib21lJ11cIj48ZGl2IGNsYXNzPVwibWVudS1pdGVtXCI+SG9tZTwvZGl2PjwvYT5cclxuICAgICAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy9CdXR0b25zJ11cIj48ZGl2IGNsYXNzPVwibWVudS1pdGVtXCI+QnV0dG9uPC9kaXY+PC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL0lucHV0J11cIj48ZGl2IGNsYXNzPVwibWVudS1pdGVtXCI+SW5wdXQ8L2Rpdj48L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPGEgW3JvdXRlckxpbmtdPVwiWycvTm90aWZpY2F0aW9ucyddXCI+PGRpdiBjbGFzcz1cIm1lbnUtaXRlbVwiPk5vdGlmaWNhdGlvbnM8L2Rpdj48L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPGEgW3JvdXRlckxpbmtdPVwiWycvVGFibGUnXVwiPjxkaXYgY2xhc3M9XCJtZW51LWl0ZW1cIj5UYWJsZTwvZGl2PjwvYT5cclxuICAgICAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy9TbGlkZXInXVwiPjxkaXYgY2xhc3M9XCJtZW51LWl0ZW1cIj5TbGlkZXI8L2Rpdj48L2E+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICA8L2Rpdj5gXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZW51UGFuZWwge1xyXG5cclxuICAgQElucHV0KCkgb3BlbjogYm9vbGVhbjtcclxuICAgY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gICBjb25zdHJ1Y3RvcigpIHtcclxuICAgfVxyXG5cclxuICAgcHVibGljIGNsb3NlTWVudVBhbmVsKCkge1xyXG4gICAgIHRoaXMub3BlbiA9IGZhbHNlO1xyXG4gICAgIHRoaXMuY2xvc2UubmV4dChudWxsKTtcclxuICAgfVxyXG4gfVxyXG4iLCJleHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uUHJvdmlkZXIge1xyXG5cclxuICBwcml2YXRlIF9ub3RpZmljYXRpb25FbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIHRoaXMuX25vdGlmaWNhdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vdGlmaWNhdGlvbi1zdHJlYW1cIik7XHJcblxyXG4gICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbkVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgIHRoaXMuX25vdGlmaWNhdGlvbkVsZW1lbnQuaWQgPSBcIm5vdGlmaWNhdGlvbi1zdHJlYW1cIjtcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9ub3RpZmljYXRpb25FbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2hvd1N1Y2Nlc3ModGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgbmV3Tm90aWZpY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIG5ld05vdGlmaWNhdGlvbi5jbGFzc05hbWUgPSBcIm5vdGlmaWNhdGlvbiBzdWNjZXNzXCI7XHJcbiAgICB0aGlzLl9zaG93Tm90aWZpY2F0aW9uKG5ld05vdGlmaWNhdGlvbiwgdGl0bGUsIG1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNob3dFcnJvcih0aXRsZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgIGxldCBuZXdOb3RpZmljYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgbmV3Tm90aWZpY2F0aW9uLmNsYXNzTmFtZSA9IFwibm90aWZpY2F0aW9uIGVycm9yXCI7XHJcbiAgICB0aGlzLl9zaG93Tm90aWZpY2F0aW9uKG5ld05vdGlmaWNhdGlvbiwgdGl0bGUsIG1lc3NhZ2UpO1xyXG5cclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3Nob3dOb3RpZmljYXRpb24obm90aWZpY2F0aW9uRWxlbWVudDogSFRNTEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgIG5vdGlmaWNhdGlvbkVsZW1lbnQuaW5uZXJIVE1MICs9IFwiPGRpdiBjbGFzcz0ndGl0bGUnPlwiICsgdGl0bGUgKyBcIjwvZGl2PlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgIG5vdGlmaWNhdGlvbkVsZW1lbnQuaW5uZXJIVE1MICs9IFwiPGRpdiBjbGFzcz0nbWVzc2FnZSc+XCIgKyBtZXNzYWdlICsgXCI8L2Rpdj5cIjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9ub3RpZmljYXRpb25FbGVtZW50LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbkVsZW1lbnQpO1xyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25FbGVtZW50LnJlbW92ZUNoaWxkKG5vdGlmaWNhdGlvbkVsZW1lbnQpO1xyXG4gICAgfSwgNTAwMCk7XHJcblxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ2FuZ3VsYXIyL2NvcmUnO1xyXG5cclxuQFBpcGUoe25hbWU6ICdzb3J0JyxcclxuICBwdXJlOiBmYWxzZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU29ydFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IEFycmF5PGFueT4sIGFyZ3M6IEFycmF5PHN0cmluZz4pOiBhbnkge1xyXG5cclxuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhcmdzWzBdO1xyXG5cclxuICAgIGlmIChwcm9wZXJ0eU5hbWVbMF0gPT09IFwiLVwiKSB7XHJcbiAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZS5zdWJzdHIoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNvcnRlZFZhbHVlID0gdmFsdWUuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBpZiAoYVtwcm9wZXJ0eU5hbWVdIDwgYltwcm9wZXJ0eU5hbWVdKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGFbcHJvcGVydHlOYW1lXSA+IGJbcHJvcGVydHlOYW1lXSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoYXJnc1swXVswXSA9PT0gXCItXCIpIHtcclxuICAgICAgc29ydGVkVmFsdWUgPSBzb3J0ZWRWYWx1ZS5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNvcnRlZFZhbHVlO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gXCJhbmd1bGFyMi9jb3JlXCI7XHJcbmltcG9ydCB7IE5nQ2xhc3MgfSBmcm9tIFwiYW5ndWxhcjIvY29tbW9uXCI7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgZGlyZWN0aXZlczogWyBOZ0NsYXNzIF0sXHJcbiAgICBzZWxlY3RvcjogXCJmZWVsLXNsaWRlclwiLFxyXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2xpZGVyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzbGlkZXItYnV0dG9uXCIgW3N0eWxlLmxlZnRdPVwiX29mZnNldFwiIChtb3VzZWRvd24pPVwiX3N0YXJ0RHJhZygkZXZlbnQpXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgIDwvZGl2PmBcclxufSlcclxuZXhwb3J0IGNsYXNzIFNsaWRlciB7XHJcblxyXG4gICBASW5wdXQoKVxyXG4gICB2YWx1ZTogbnVtYmVyO1xyXG4gICBAT3V0cHV0KClcclxuICAgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gICBwcml2YXRlIF9vZmZzZXQ6IHN0cmluZztcclxuXHJcbiAgIHByaXZhdGUgX2J1dHRvbkVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG5cclxuXHJcbiAgIEBJbnB1dCgpXHJcbiAgIG1heGltdW06IG51bWJlcjtcclxuXHJcbiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLl9jYWxjdWxhdGVPZmZzZXQoKTtcclxuICAgfVxyXG5cclxuICAgcHJpdmF0ZSBfY2FsY3VsYXRlT2Zmc2V0KCkge1xyXG4gICAgICB0aGlzLl9vZmZzZXQgPSAoKHRoaXMudmFsdWUgLyB0aGlzLm1heGltdW0pICogMTAwKS50b1N0cmluZygpICsgXCIlXCI7XHJcbiAgIH1cclxuXHJcbiAgIHByaXZhdGUgX3N0YXJ0RHJhZyhldmVudDogTW91c2VFdmVudCkge1xyXG4gICAgICB0aGlzLl9idXR0b25FbGVtZW50ID0gPEhUTUxFbGVtZW50PmV2ZW50LnRhcmdldDtcclxuXHJcbiAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IHRoaXMuX3N0b3BEcmFnLmJpbmQodGhpcyk7XHJcbiAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gdGhpcy5faGFuZGxlRHJhZy5iaW5kKHRoaXMpO1xyXG4gICB9XHJcblxyXG4gICBwcml2YXRlIF9oYW5kbGVEcmFnKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5fYnV0dG9uRWxlbWVudDtcclxuICAgICAgbGV0IG9mZnNldFRvdGFsID0gdGhpcy5fYnV0dG9uRWxlbWVudC5vZmZzZXRMZWZ0O1xyXG5cclxuICAgICAgd2hpbGUgKGVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+ZWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgaWYgKCFpc05hTihlbGVtZW50Lm9mZnNldExlZnQpKSB7XHJcbiAgICAgICAgICAgIG9mZnNldFRvdGFsICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgdmFsdWUgPSAoZXZlbnQucGFnZVggLyB0aGlzLl9idXR0b25FbGVtZW50LnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGgpICogdGhpcy5tYXhpbXVtO1xyXG5cclxuICAgICAgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICB0aGlzLnZhbHVlID0gMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh2YWx1ZSA+IHRoaXMubWF4aW11bSkge1xyXG4gICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5tYXhpbXVtO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZU9mZnNldCgpO1xyXG4gICAgICB0aGlzLl9idXR0b25FbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLl9vZmZzZXQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMudmFsdWUpO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcclxuICAgfVxyXG5cclxuICAgcHJpdmF0ZSBfc3RvcERyYWcoKSB7XHJcbiAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGw7XHJcbiAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuICAgfVxyXG4gfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tIFwiYW5ndWxhcjIvY29yZVwiO1xyXG5pbXBvcnQgeyBOZ0NsYXNzLCBOZ0lmLCBOZ01vZGVsIH0gZnJvbSBcImFuZ3VsYXIyL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBTb3J0UGlwZSB9IGZyb20gXCIuL3BpcGVzL3NvcnQtcGlwZVwiO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBkaXJlY3RpdmVzOiBbIE5nQ2xhc3MgXSxcclxuICAgIHNlbGVjdG9yOiBcImZlZWwtdGFibGVcIixcclxuICAgIHBpcGVzOiBbIFNvcnRQaXBlIF0sXHJcbiAgICAvL2NoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgdGVtcGxhdGU6IGA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgPHRoICpuZ0Zvcj1cIiNjb2x1bW4gb2YgY29sdW1uc1wiIChjbGljayk9YWRkU29ydChjb2x1bW4ucHJvcGVydHlOYW1lKT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3sgY29sdW1uLnByb3BlcnR5TmFtZSB9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW25nQ2xhc3NdPVxcXCJ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FzY2VuZGluZyc6IHNvcnRJdGVtc1swXSA9PT0gY29sdW1uLnByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVzY2VuZGluZyc6IHNvcnRJdGVtc1swXSA9PT0gJy0nICsgY29sdW1uLnByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc29ydC1pY29uJzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcIiA+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICA8L3RoPlxyXG4gICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgIDx0ciAqbmdGb3I9XCIjZGF0YUl0ZW0gb2YgZGF0YSB8IHNvcnQ6IHNvcnRPcmRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgKm5nRm9yPVwiI2NvbHVtbiBvZiBjb2x1bW5zXCI+e3sgZGF0YUl0ZW1bY29sdW1uLnByb3BlcnR5TmFtZV0gfX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICA8L3RhYmxlPmBcclxufSlcclxuZXhwb3J0IGNsYXNzIFRhYmxlQ29tcG9uZW50IHtcclxuXHJcbiAgIEBJbnB1dCgpIGRhdGE6IEFycmF5PGFueT47XHJcbiAgIEBJbnB1dCgpIGNvbHVtbnM6IEFycmF5PGFueT47XHJcbiAgIHB1YmxpYyBzb3J0T3JkZXI6IHN0cmluZyA9IFwic29tZXRoaW5nXCI7XHJcbiAgIHB1YmxpYyBzb3J0SXRlbXM6IEFycmF5PHN0cmluZz4gPSBbIFwic29tZXRoaW5nXCIgXTtcclxuXHJcbiAgIHB1YmxpYyBhZGRTb3J0IChwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xyXG4gICAgIGlmICh0aGlzLnNvcnRPcmRlciA9PT0gcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICB0aGlzLnNvcnRPcmRlciA9IFwiLVwiICsgcHJvcGVydHlOYW1lO1xyXG4gICAgIH1cclxuICAgICBlbHNlIHtcclxuICAgICAgIHRoaXMuc29ydE9yZGVyID0gcHJvcGVydHlOYW1lO1xyXG4gICAgIH1cclxuXHJcbiAgICAgdGhpcy5zb3J0SXRlbXNbMF0gPSB0aGlzLnNvcnRPcmRlcjtcclxuICAgfVxyXG4gfVxyXG4iXX0=
